<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lightweight Charts Bridge</title>
    <style>
      html, body, #app { margin: 0; padding: 0; height: 100%; background: #0b0f13; }
      #container { width: 100%; height: 100%; position: relative; }
      #legend {
        position: absolute;
        top: 4px;
        left: 4px;
        right: 70px;
        z-index: 10;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 10px;
        color: #c5ced9;
        display: flex;
        flex-wrap: wrap;
        gap: 4px 6px;
        pointer-events: none;
      }
      #legend .label { color: #888; }
      #legend .value { font-weight: 500; }
      #legend .bullish { color: #26a69a; }
      #legend .bearish { color: #ffffff; }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  </head>
  <body>
    <div id="app">
      <div id="container">
        <div id="legend"></div>
      </div>
    </div>
    <script>
      (function () {
        const emitter = window.ReactNativeWebView ? {
          post: (msg) => window.ReactNativeWebView.postMessage(JSON.stringify(msg)),
        } : {
          post: (msg) => console.log('bridge->rn', msg),
        };

        let chart, candleSeries, smaSeries;
        let lastBarTime = null;
        let priceLines = [];
        let allMarkers = [];
        let latestCandle = null;

        function computeSMA(data, period) {
          const result = [];
          let sum = 0;
          for (let i = 0; i < data.length; i++) {
            const close = data[i].close;
            sum += close;
            if (i >= period) {
              sum -= data[i - period].close;
            }
            if (i >= period - 1) {
              result.push({ time: data[i].time, value: sum / period });
            }
          }
          return result;
        }

        function formatPrice(price) {
          if (price === 0) return '0';
          const absPrice = Math.abs(price);
          let decimals;
          if (absPrice < 0.0001) decimals = 8;
          else if (absPrice < 0.001) decimals = 7;
          else if (absPrice < 0.01) decimals = 6;
          else if (absPrice < 0.1) decimals = 5;
          else if (absPrice < 1) decimals = 4;
          else decimals = 2;
          return price.toFixed(decimals);
        }

        function updateLegend(candle) {
          const legend = document.getElementById('legend');
          const displayCandle = (candle && candle.open !== undefined) ? candle : latestCandle;
          if (!displayCandle || displayCandle.open === undefined) {
            legend.innerHTML = '';
            return;
          }
          candle = displayCandle;

          const isBullish = candle.close >= candle.open;
          const colorClass = isBullish ? 'bullish' : 'bearish';
          const dollarChange = candle.close - candle.open;
          const percentChange = ((dollarChange / candle.open) * 100);
          const sign = dollarChange >= 0 ? '+' : '';

          legend.innerHTML = `
            <span><span class="label">O</span> <span class="value ${colorClass}">${formatPrice(candle.open)}</span></span>
            <span><span class="label">H</span> <span class="value ${colorClass}">${formatPrice(candle.high)}</span></span>
            <span><span class="label">L</span> <span class="value ${colorClass}">${formatPrice(candle.low)}</span></span>
            <span><span class="label">C</span> <span class="value ${colorClass}">${formatPrice(candle.close)}</span></span>
            <span class="value ${colorClass}">${sign}${formatPrice(dollarChange)} (${sign}${percentChange.toFixed(2)}%)</span>
          `;
        }

        function onCrosshairMove(param) {
          if (!param || !param.seriesData) {
            updateLegend(null);
            return;
          }
          const candle = param.seriesData.get(candleSeries);
          updateLegend(candle);
        }

        function updateVisibleMarkers() {
          if (!chart || !candleSeries || allMarkers.length === 0) return;
          
          try {
            const timeScale = chart.timeScale();
            const visibleLogicalRange = timeScale.getVisibleLogicalRange();
            
            if (!visibleLogicalRange) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Get all candle data to map logical indices to times
            const barsInfo = candleSeries.barsInLogicalRange(visibleLogicalRange);
            
            if (!barsInfo) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Get the time range of visible candles
            const visibleTimeRange = timeScale.getVisibleRange();
            
            if (!visibleTimeRange) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Filter markers to only those within the visible time range
            const visibleMarkers = allMarkers.filter(marker => {
              return marker.time >= visibleTimeRange.from && marker.time <= visibleTimeRange.to;
            });
            
            candleSeries.setMarkers(visibleMarkers);
          } catch (e) {
            // If any error occurs, show all markers as fallback
            console.error('Error updating visible markers:', e);
            candleSeries.setMarkers(allMarkers);
          }
        }

        function ensureChart(opts) {
          const el = document.getElementById('container');
          if (!chart) {
            chart = LightweightCharts.createChart(el, {
              width: opts.width || el.clientWidth,
              height: opts.height || el.clientHeight,
              layout: {
                background: { color: (opts.theme && opts.theme.bg) || '#0b0f13' },
                textColor: (opts.theme && opts.theme.fg) || '#c5ced9',
              },
              rightPriceScale: { borderVisible: false },
              timeScale: { 
                borderVisible: false,
                timeVisible: true,
                secondsVisible: false,
                rightOffset: 5,
              },
              grid: { vertLines: { color: '#161b22' }, horzLines: { color: '#161b22' } },
            });
            candleSeries = chart.addCandlestickSeries({
              upColor: '#26a69a', downColor: '#ffffff', borderVisible: false,
              wickUpColor: '#26a69a', wickDownColor: '#ffffff',
              priceFormat: {
                type: 'custom',
                formatter: (price) => {
                  if (price === 0) return '0';
                  const absPrice = Math.abs(price);
                  let decimals;
                  if (absPrice < 0.0001) {
                    decimals = 8;
                  } else if (absPrice < 0.001) {
                    decimals = 7;
                  } else if (absPrice < 0.01) {
                    decimals = 6;
                  } else if (absPrice < 0.1) {
                    decimals = 5;
                  } else if (absPrice < 1) {
                    decimals = 4;
                  } else {
                    decimals = 2;
                  }
                  return price.toFixed(decimals);
                },
                minMove: 0.00000001,
              },
            });
            
            // Subscribe to visible range changes to update markers dynamically
            chart.timeScale().subscribeVisibleLogicalRangeChange(updateVisibleMarkers);

            // Subscribe to crosshair move to update OHLC legend
            chart.subscribeCrosshairMove(onCrosshairMove);
          } else {
            chart.applyOptions({ width: opts.width, height: opts.height });
          }
        }

        function handleMessage(event) {
          let data;
          try { data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data; }
          catch (e) { return; }
          const { type, payload } = data || {};
          if (!type) return;

          if (type === 'init') {
            ensureChart(payload || {});
            emitter.post({ type: 'ready' });
          }

          if (type === 'setData') {
            if (!chart) ensureChart({});
            const candles = payload.candles || [];
            
            // Add whitespace data points for future dates to show on x-axis
            let extendedData = candles;
            if (candles.length >= 2) {
              // Calculate the interval between candles
              const lastCandle = candles[candles.length - 1];
              const secondLastCandle = candles[candles.length - 2];
              const interval = lastCandle.time - secondLastCandle.time;
              
              // Generate 25 future whitespace points (only time property, no OHLC)
              const futurePoints = [];
              for (let i = 1; i <= 350; i++) {
                futurePoints.push({
                  time: lastCandle.time + (interval * i)
                });
              }
              
              // Combine actual candles with future whitespace points
              extendedData = candles.concat(futurePoints);
            }
            
            candleSeries.setData(extendedData);
            if (candles.length) {
              lastBarTime = candles[candles.length - 1].time;
              latestCandle = candles[candles.length - 1];
              updateLegend(null);
            }
          }

          if (type === 'updateBar') {
            if (!candleSeries) return;
            const bar = payload.bar;
            if (lastBarTime === bar.time) {
              candleSeries.update(bar);
            } else {
              candleSeries.update(bar);
              lastBarTime = bar.time;
            }
            latestCandle = bar;
            updateLegend(null);
          }

          if (type === 'setSMA') {
            if (!chart) return;
            const period = payload.period || 20;
            const range = candleSeries.dataByIndex ? null : null;
            // We need the full current data; WebView can't read it from series.
            // Expect RN to send both setData before setSMA, so we recompute over last setData cache if needed.
            // For simplicity, RN will send candles again with setSMA if desired in future.
            if (payload.candles) {
              const candles = payload.candles;
              const sma = computeSMA(candles, period);
              if (!smaSeries) smaSeries = chart.addLineSeries({ color: '#5ab0ff', lineWidth: 2 });
              smaSeries.setData(sma);
            }
          }

          if (type === 'resize') {
            if (chart) chart.applyOptions({ width: payload.width, height: payload.height });
          }

          if (type === 'setMarkers') {
            if (!candleSeries) return;
            allMarkers = payload.markers || [];
            updateVisibleMarkers();
          }

          if (type === 'setPriceLines') {
            if (!candleSeries) return;
            // Remove existing price lines
            priceLines.forEach(line => {
              try {
                candleSeries.removePriceLine(line);
              } catch (e) {
                // Ignore errors if line was already removed
              }
            });
            priceLines = [];
            
            // Add new price lines
            const lines = payload.lines || [];
            lines.forEach(lineConfig => {
              try {
                const priceLine = candleSeries.createPriceLine({
                  price: lineConfig.price,
                  color: lineConfig.color,
                  lineWidth: lineConfig.lineWidth || 1,
                  lineStyle: lineConfig.lineStyle === 'dashed' ? 2 : 0, // 0 = solid, 2 = dashed
                  axisLabelVisible: true,
                  title: lineConfig.title || '',
                });
                priceLines.push(priceLine);
              } catch (e) {
                console.error('Error creating price line:', e);
              }
            });
          }
        }

        document.addEventListener('message', handleMessage);
        window.addEventListener('message', handleMessage);
      })();
    </script>
  </body>
  </html>


