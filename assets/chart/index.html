<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lightweight Charts Bridge</title>
    <style>
      html, body, #app { margin: 0; padding: 0; height: 100%; background: #0b0f13; }
      #container { width: 100%; height: 100%; }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  </head>
  <body>
    <div id="app">
      <div id="container"></div>
    </div>
    <script>
      (function () {
        const emitter = window.ReactNativeWebView ? {
          post: (msg) => window.ReactNativeWebView.postMessage(JSON.stringify(msg)),
        } : {
          post: (msg) => console.log('bridge->rn', msg),
        };

        let chart, candleSeries, smaSeries;
        let lastBarTime = null;
        let priceLines = [];
        let allMarkers = [];

        function computeSMA(data, period) {
          const result = [];
          let sum = 0;
          for (let i = 0; i < data.length; i++) {
            const close = data[i].close;
            sum += close;
            if (i >= period) {
              sum -= data[i - period].close;
            }
            if (i >= period - 1) {
              result.push({ time: data[i].time, value: sum / period });
            }
          }
          return result;
        }

        function updateVisibleMarkers() {
          if (!chart || !candleSeries || allMarkers.length === 0) return;
          
          try {
            const timeScale = chart.timeScale();
            const visibleLogicalRange = timeScale.getVisibleLogicalRange();
            
            if (!visibleLogicalRange) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Get all candle data to map logical indices to times
            const barsInfo = candleSeries.barsInLogicalRange(visibleLogicalRange);
            
            if (!barsInfo) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Get the time range of visible candles
            const visibleTimeRange = timeScale.getVisibleRange();
            
            if (!visibleTimeRange) {
              candleSeries.setMarkers(allMarkers);
              return;
            }
            
            // Filter markers to only those within the visible time range
            const visibleMarkers = allMarkers.filter(marker => {
              return marker.time >= visibleTimeRange.from && marker.time <= visibleTimeRange.to;
            });
            
            candleSeries.setMarkers(visibleMarkers);
          } catch (e) {
            // If any error occurs, show all markers as fallback
            console.error('Error updating visible markers:', e);
            candleSeries.setMarkers(allMarkers);
          }
        }

        function ensureChart(opts) {
          const el = document.getElementById('container');
          if (!chart) {
            chart = LightweightCharts.createChart(el, {
              width: opts.width || el.clientWidth,
              height: opts.height || el.clientHeight,
              layout: {
                background: { color: (opts.theme && opts.theme.bg) || '#0b0f13' },
                textColor: (opts.theme && opts.theme.fg) || '#c5ced9',
              },
              rightPriceScale: { borderVisible: false },
              timeScale: { 
                borderVisible: false,
                timeVisible: true,
                secondsVisible: false
              },
              grid: { vertLines: { color: '#161b22' }, horzLines: { color: '#161b22' } },
            });
            candleSeries = chart.addCandlestickSeries({
              upColor: '#26a69a', downColor: '#ffffff', borderVisible: false,
              wickUpColor: '#26a69a', wickDownColor: '#ffffff',
            });
            
            // Subscribe to visible range changes to update markers dynamically
            chart.timeScale().subscribeVisibleLogicalRangeChange(updateVisibleMarkers);
          } else {
            chart.applyOptions({ width: opts.width, height: opts.height });
          }
        }

        function handleMessage(event) {
          let data;
          try { data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data; }
          catch (e) { return; }
          const { type, payload } = data || {};
          if (!type) return;

          if (type === 'init') {
            ensureChart(payload || {});
            emitter.post({ type: 'ready' });
          }

          if (type === 'setData') {
            if (!chart) ensureChart({});
            const candles = payload.candles || [];
            candleSeries.setData(candles);
            if (candles.length) {
              lastBarTime = candles[candles.length - 1].time;
            }
          }

          if (type === 'updateBar') {
            if (!candleSeries) return;
            const bar = payload.bar;
            if (lastBarTime === bar.time) {
              candleSeries.update(bar);
            } else {
              candleSeries.update(bar);
              lastBarTime = bar.time;
            }
          }

          if (type === 'setSMA') {
            if (!chart) return;
            const period = payload.period || 20;
            const range = candleSeries.dataByIndex ? null : null;
            // We need the full current data; WebView can't read it from series.
            // Expect RN to send both setData before setSMA, so we recompute over last setData cache if needed.
            // For simplicity, RN will send candles again with setSMA if desired in future.
            if (payload.candles) {
              const candles = payload.candles;
              const sma = computeSMA(candles, period);
              if (!smaSeries) smaSeries = chart.addLineSeries({ color: '#5ab0ff', lineWidth: 2 });
              smaSeries.setData(sma);
            }
          }

          if (type === 'resize') {
            if (chart) chart.applyOptions({ width: payload.width, height: payload.height });
          }

          if (type === 'setMarkers') {
            if (!candleSeries) return;
            allMarkers = payload.markers || [];
            updateVisibleMarkers();
          }

          if (type === 'setPriceLines') {
            if (!candleSeries) return;
            // Remove existing price lines
            priceLines.forEach(line => {
              try {
                candleSeries.removePriceLine(line);
              } catch (e) {
                // Ignore errors if line was already removed
              }
            });
            priceLines = [];
            
            // Add new price lines
            const lines = payload.lines || [];
            lines.forEach(lineConfig => {
              try {
                const priceLine = candleSeries.createPriceLine({
                  price: lineConfig.price,
                  color: lineConfig.color,
                  lineWidth: lineConfig.lineWidth || 1,
                  lineStyle: lineConfig.lineStyle === 'dashed' ? 2 : 0, // 0 = solid, 2 = dashed
                  axisLabelVisible: true,
                  title: lineConfig.title || '',
                });
                priceLines.push(priceLine);
              } catch (e) {
                console.error('Error creating price line:', e);
              }
            });
          }
        }

        document.addEventListener('message', handleMessage);
        window.addEventListener('message', handleMessage);
      })();
    </script>
  </body>
  </html>


